package tui

import (
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/charmbracelet/bubbles/spinner"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/joshuawatkins04/thunder-cli-draft/api"
)

type PresetSaveResult struct {
	Name   string
	Config CreateConfig
}

type presetSaveStep int

const (
	presetStepConfig presetSaveStep = iota
	presetStepName
	presetStepComplete
)

// PresetSaveModel manages the preset save interactive flow
type presetSaveModel struct {
	step              presetSaveStep
	configStep        createStep
	cursor            int
	config            CreateConfig
	templates         []api.Template
	templatesLoaded   bool
	diskInput         textinput.Model
	nameInput         textinput.Model
	autoGeneratedName string
	err               error
	quitting          bool
	client            *api.Client
	spinner           spinner.Model
}

// presetTemplatesMsg handles template loading
type presetTemplatesMsg struct {
	templates []api.Template
	err       error
}

// NewPresetSaveModel creates a new preset save model
func NewPresetSaveModel(client *api.Client) presetSaveModel {
	tiDisk := textinput.New()
	tiDisk.Placeholder = "100"
	tiDisk.CharLimit = 4
	tiDisk.Width = 20

	tiName := textinput.New()
	tiName.Placeholder = "Enter preset name"
	tiName.Width = 40

	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = lipgloss.NewStyle().Foreground(lipgloss.Color("#0391ff"))

	return presetSaveModel{
		step:       presetStepConfig,
		configStep: stepMode,
		client:     client,
		diskInput:  tiDisk,
		nameInput:  tiName,
		spinner:    s,
		config: CreateConfig{
			DiskSizeGB: 100,
		},
	}
}

func fetchPresetTemplatesCmd(client *api.Client) tea.Cmd {
	return func() tea.Msg {
		templates, err := client.ListTemplates()
		if err == nil {
			templates = sortTemplates(templates)
		}
		return presetTemplatesMsg{templates: templates, err: err}
	}
}

func (m presetSaveModel) Init() tea.Cmd {
	return tea.Batch(fetchPresetTemplatesCmd(m.client), m.spinner.Tick)
}

func (m presetSaveModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case presetTemplatesMsg:
		if msg.err != nil {
			m.err = msg.err
			return m, tea.Quit
		}
		m.templates = msg.templates
		m.templatesLoaded = true
		if len(m.templates) == 0 {
			m.err = fmt.Errorf("no templates available")
			return m, tea.Quit
		}
		return m, m.spinner.Tick

	case spinner.TickMsg:
		var cmd tea.Cmd
		m.spinner, cmd = m.spinner.Update(msg)
		if !m.templatesLoaded {
			return m, tea.Batch(cmd, m.spinner.Tick)
		}
		return m, cmd

	case tea.KeyMsg:
		switch msg.String() {
		case "q", "ctrl+c":
			if m.step != presetStepName {
				m.quitting = true
				return m, tea.Quit
			}

		case "esc":
			if m.step == presetStepName {
				m.step = presetStepConfig
				m.cursor = 0
			} else if m.configStep > stepMode {
				m.configStep--
			}

		case "enter":
			return m.handleEnter()

		case "up", "k":
			if m.step == presetStepConfig && m.cursor > 0 {
				m.cursor--
			}

		case "down", "j":
			maxCursor := m.getMaxCursor()
			if m.step == presetStepConfig && m.cursor < maxCursor {
				m.cursor++
			}
		}
	}

	// Handle text input updates
	if m.step == presetStepConfig && m.configStep == stepDiskSize {
		var cmd tea.Cmd
		m.diskInput, cmd = m.diskInput.Update(msg)
		return m, cmd
	} else if m.step == presetStepName {
		var cmd tea.Cmd
		m.nameInput, cmd = m.nameInput.Update(msg)
		return m, cmd
	}

	return m, nil
}

func (m presetSaveModel) handleEnter() (tea.Model, tea.Cmd) {
	if m.step == presetStepConfig {
		return m.handleConfigStep()
	} else if m.step == presetStepName {
		name := strings.TrimSpace(m.nameInput.Value())
		if name == "" {
			name = m.autoGeneratedName
		}

		if name == "" {
			m.err = fmt.Errorf("preset name cannot be empty")
			return m, nil
		}

		return m, tea.Quit
	}

	return m, nil
}

func (m presetSaveModel) handleConfigStep() (tea.Model, tea.Cmd) {
	switch m.configStep {
	case stepMode:
		modes := []string{"prototyping", "production"}
		m.config.Mode = modes[m.cursor]
		m.configStep = stepGPU
		m.cursor = 0

	case stepGPU:
		gpus := m.getGPUOptions()
		m.config.GPUType = gpus[m.cursor]
		m.configStep = stepCompute
		m.cursor = 0

	case stepCompute:
		if m.config.Mode == "prototyping" {
			vcpus := []int{4, 8, 16, 32}
			m.config.VCPUs = vcpus[m.cursor]
			m.config.NumGPUs = 1
		} else {
			numGPUs := []int{1, 2, 4}
			m.config.NumGPUs = numGPUs[m.cursor]
			m.config.VCPUs = 18 * m.config.NumGPUs
		}
		m.configStep = stepTemplate
		m.cursor = 0

	case stepTemplate:
		if m.cursor < len(m.templates) {
			m.config.Template = m.templates[m.cursor].Key
			m.configStep = stepDiskSize
			m.diskInput.Focus()
			m.diskInput.SetValue("100")
		}

	case stepDiskSize:
		diskSize, err := strconv.Atoi(m.diskInput.Value())
		if err != nil || diskSize < 100 || diskSize > 1000 {
			m.err = fmt.Errorf("disk size must be between 100 and 1000 GB")
			return m, nil
		}
		m.config.DiskSizeGB = diskSize
		m.err = nil

		// Generate auto name and move to name step
		m.autoGeneratedName = GeneratePresetNameFromConfig(&m.config)
		m.step = presetStepName
		m.nameInput.SetValue(m.autoGeneratedName)
		m.nameInput.Focus()
		m.cursor = 0
	}

	return m, nil
}

func (m presetSaveModel) getGPUOptions() []string {
	if m.config.Mode == "prototyping" {
		return []string{"t4", "a100xl"}
	}
	return []string{"a100xl", "h100xl"}
}

func (m presetSaveModel) getMaxCursor() int {
	switch m.configStep {
	case stepMode:
		return 1
	case stepGPU:
		return len(m.getGPUOptions()) - 1
	case stepCompute:
		if m.config.Mode == "prototyping" {
			return 3
		}
		return 2
	case stepTemplate:
		return len(m.templates) - 1
	}
	return 0
}

func (m presetSaveModel) View() string {
	if m.err != nil {
		return fmt.Sprintf("Error: %v\n", m.err)
	}

	if m.quitting {
		return "Operation cancelled.\n"
	}

	if m.step == presetStepComplete {
		return ""
	}

	var s strings.Builder

	if m.step == presetStepConfig {
		s.WriteString(titleStyle.Render("⚡ Save Instance Configuration as Preset"))
		s.WriteString("\n\n")

		// Render current config step
		m.renderConfigStep(&s)

	} else if m.step == presetStepName {
		s.WriteString(titleStyle.Render("⚡ Name Your Preset"))
		s.WriteString("\n\n")

		s.WriteString("Enter a name for this preset:\n\n")
		s.WriteString(m.nameInput.View())
		s.WriteString("\n\n")

		if m.autoGeneratedName != "" {
			helpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#666"))
			s.WriteString(helpStyle.Render(fmt.Sprintf("Auto-generated: %s", m.autoGeneratedName)))
			s.WriteString("\n")
		}

		s.WriteString("\nPress Enter to save, 'Esc' to go back\n")
	}

	return s.String()
}

func (m presetSaveModel) renderConfigStep(s *strings.Builder) {
	// Progress indicator
	progressSteps := []string{"Mode", "GPU", "Compute", "Template", "Disk"}
	progress := ""
	for i, stepName := range progressSteps {
		adjustedStep := int(m.configStep)
		if i == adjustedStep {
			progress += selectedStyle.Render(fmt.Sprintf("[%s]", stepName))
		} else if i < adjustedStep {
			progress += fmt.Sprintf("[✓ %s]", stepName)
		} else {
			progress += fmt.Sprintf("[%s]", stepName)
		}
		if i < len(progressSteps)-1 {
			progress += " → "
		}
	}
	s.WriteString(progress)
	s.WriteString("\n\n")

	// Render current step content
	switch m.configStep {
	case stepMode:
		s.WriteString("Select instance mode:\n\n")
		modes := []string{"Prototyping (lowest cost, dev/test)", "Production (highest stability, long-running)"}
		for i, mode := range modes {
			cursor := "  "
			if m.cursor == i {
				cursor = cursorStyle.Render("▶ ")
			}
			s.WriteString(fmt.Sprintf("%s%s\n", cursor, mode))
		}

	case stepGPU:
		s.WriteString("Select GPU type:\n\n")
		gpus := m.getGPUOptions()
		for i, gpu := range gpus {
			cursor := "  "
			if m.cursor == i {
				cursor = cursorStyle.Render("▶ ")
			}
			displayName := strings.ToUpper(gpu)
			s.WriteString(fmt.Sprintf("%s%s\n", cursor, displayName))
		}

	case stepCompute:
		if m.config.Mode == "prototyping" {
			s.WriteString("Select vCPU count (8GB RAM per vCPU):\n\n")
			vcpus := []int{4, 8, 16, 32}
			for i, vcpu := range vcpus {
				cursor := "  "
				if m.cursor == i {
					cursor = cursorStyle.Render("▶ ")
				}
				ram := vcpu * 8
				s.WriteString(fmt.Sprintf("%s%d vCPUs (%d GB RAM)\n", cursor, vcpu, ram))
			}
		} else {
			s.WriteString("Select number of GPUs (18 vCPUs per GPU, 144GB RAM per GPU):\n\n")
			numGPUs := []int{1, 2, 4}
			for i, num := range numGPUs {
				cursor := "  "
				if m.cursor == i {
					cursor = cursorStyle.Render("▶ ")
				}
				vcpus := num * 18
				s.WriteString(fmt.Sprintf("%s%d GPU(s) → %d vCPUs\n", cursor, num, vcpus))
			}
		}

	case stepTemplate:
		s.WriteString("Select OS template:\n\n")
		if !m.templatesLoaded {
			s.WriteString(fmt.Sprintf("%s Loading templates...\n", m.spinner.View()))
		} else {
			for i, template := range m.templates {
				cursor := "  "
				if m.cursor == i {
					cursor = cursorStyle.Render("▶ ")
				}
				name := template.DisplayName
				if template.ExtendedDescription != "" {
					name += fmt.Sprintf(" - %s", template.ExtendedDescription)
				}
				s.WriteString(fmt.Sprintf("%s%s\n", cursor, name))
			}
		}

	case stepDiskSize:
		s.WriteString("Enter disk size (GB):\n\n")
		s.WriteString("Range: 100-1000 GB\n\n")
		s.WriteString(m.diskInput.View())
		s.WriteString("\n\n")
		if m.err != nil {
			s.WriteString(errorStyle.Render(m.err.Error()))
			s.WriteString("\n")
		}
		s.WriteString("Press Enter to continue\n")
	}

	s.WriteString("\n")
	s.WriteString("↑/↓: Navigate  Enter: Select  Esc: Back  Q: Cancel\n")
}

// RunPresetSaveInteractive runs the preset save interactive flow
func RunPresetSaveInteractive(client *api.Client) (*PresetSaveResult, error) {
	m := NewPresetSaveModel(client)
	p := tea.NewProgram(m)
	finalModel, err := p.Run()
	if err != nil {
		return nil, fmt.Errorf("error running TUI: %w", err)
	}

	result := finalModel.(presetSaveModel)

	if result.err != nil {
		return nil, result.err
	}

	if result.quitting {
		return nil, fmt.Errorf("operation cancelled")
	}

	name := strings.TrimSpace(result.nameInput.Value())
	if name == "" {
		name = result.autoGeneratedName
	}

	return &PresetSaveResult{
		Name:   name,
		Config: result.config,
	}, nil
}

// GeneratePresetNameFromConfig generates a preset name from configuration
func GeneratePresetNameFromConfig(config *CreateConfig) string {
	var parts []string

	parts = append(parts, strings.ToLower(config.Mode))

	gpuType := strings.ToLower(config.GPUType)
	if strings.Contains(gpuType, "a100") {
		parts = append(parts, "a100")
	} else if strings.Contains(gpuType, "h100") {
		parts = append(parts, "h100")
	} else if strings.Contains(gpuType, "t4") {
		parts = append(parts, "t4")
	}

	if config.Mode == "prototyping" {
		parts = append(parts, fmt.Sprintf("%dvcpu", config.VCPUs))
	} else {
		parts = append(parts, fmt.Sprintf("%dgpu", config.NumGPUs))
	}

	template := strings.ToLower(config.Template)
	template = strings.Split(template, "-")[0]
	parts = append(parts, template)

	timestamp := time.Now().Format("20060102")
	parts = append(parts, timestamp)

	return strings.Join(parts, "-")
}

// PresetDeleteModel handles preset deletion confirmation
type PresetDeleteModel struct {
	name      string
	confirmed bool
	quitting  bool
}

func NewPresetDeleteModel(name string) PresetDeleteModel {
	return PresetDeleteModel{
		name: name,
	}
}

func (m PresetDeleteModel) Init() tea.Cmd {
	return nil
}

func (m PresetDeleteModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "y", "Y":
			m.confirmed = true
			return m, tea.Quit
		case "n", "N", "q", "ctrl+c":
			m.quitting = true
			return m, tea.Quit
		}
	}
	return m, nil
}

func (m PresetDeleteModel) View() string {
	var s strings.Builder
	s.WriteString(errorStyle.Render("⚠ Warning: This action cannot be undone!"))
	s.WriteString("\n\n")
	s.WriteString(fmt.Sprintf("Are you sure you want to delete preset '%s'?\n\n", m.name))
	s.WriteString("Press 'y' to confirm, 'Q' to cancel: ")
	return s.String()
}

func (m PresetDeleteModel) Confirmed() bool {
	return m.confirmed
}
